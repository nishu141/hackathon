import re
from typing import Dict, List, Optional
import os
import datetime

class StepGenerator:
    """Generates complete step definitions for BDD feature files"""
    
    def __init__(self):
        """Initialize step generator"""
        pass
        
    def generate_step_file(self, steps: List[str], output_path: str) -> None:
        """Generate complete step definitions file"""
        content = [
            "# AUTOGENERATED - DO NOT EDIT",
            "from behave import given, when, then",
            "import requests",
            "import json",
            "import os",
            "import time",
            "",
            "def load_config():",
            '    """Load the telecom API configuration."""',
            '    config_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "telecom_config.json")',
            '    try:',
            '        with open(config_path, "r") as f:',
            '            return json.load(f)',
            '    except Exception as e:',
            '        print(f"Error loading config: {e}")',
            '        return {}',
            ''
        ]
        
        # Process steps
        seen = set()
        for step in steps:
            # Skip duplicate steps
            step_normalized = re.sub(r'^(Given|When|Then|And|But)\s+', '', step, flags=re.IGNORECASE)
            if step_normalized in seen:
                continue
            seen.add(step_normalized)
            
            # Get step type and function name
            step_type = self._get_step_type(step)
            func_name = re.sub(r'[^a-zA-Z0-9]', '_', step_normalized.lower())
            if func_name.startswith('_'):
                func_name = func_name[1:]
            
            # Generate implementation
            impl = self._generate_step_impl(step_normalized, step_type)
            
            # Add step definition
            content.extend([
                f'@{step_type}(r"{step_normalized}")',
                f'def step_{func_name}(context, recipient=None):',
                impl,
                ""
            ])
        
        # Write to file
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, "w", encoding="utf-8") as f:
            f.write("\n".join(content))

    def _get_step_type(self, step: str) -> str:
        """Determine the appropriate step type (given/when/then) for a step"""
        step_lower = step.lower().strip()
        
        # Remove Given/When/Then/And/But prefix for better matching
        step_lower = re.sub(r'^(given|when|then|and|but)\s+', '', step_lower, flags=re.IGNORECASE)
        
        if "is configured" in step_lower or "configuration exists" in step_lower:
            return "given"
        elif "send" in step_lower or "request" in step_lower or step_lower.startswith("i "):
            return "when"
        else:
            return "then"

    def _generate_step_impl(self, step: str, step_type: str) -> str:
        """Generate the implementation for a step"""
        normalized = step.lower().strip()
        
        # Configuration step
        if "is configured" in normalized:
            return '''    """Setup the SMS API configuration for testing."""
    config = load_config()
    context.base_url = config.get('base_url', 'http://localhost:8000')
    context.api_key = config.get('api_key', 'test_key')
    context.headers = {'Authorization': f'Bearer {context.api_key}'}
    context.timeout = config.get('timeout', 10)
    context.retry_attempts = config.get('retry_attempts', 3)
    context.retry_delay = config.get('retry_delay', 1)'''

        # Send SMS step
        elif "send" in normalized and "sms" in normalized:
            return '''    """Send an SMS message to the specified recipient."""
    url = f'{context.base_url}/sms/send'
    data = {
        'recipient': recipient,
        'message': 'Test SMS message',
        'priority': 'normal'
    }
    
    # Implement retry logic
    attempts = context.retry_attempts if hasattr(context, 'retry_attempts') else 1
    for attempt in range(attempts):
        try:
            response = requests.post(url, json=data, headers=context.headers, timeout=context.timeout)
            context.response = response
            context.status_code = response.status_code
            if response.status_code == 200:
                break
            if attempt < attempts - 1:  # Don't sleep on last attempt
                time.sleep(context.retry_delay)
        except requests.exceptions.RequestException as e:
            context.response = None
            context.status_code = 500
            print(f'Error sending SMS (attempt {attempt + 1}): {e}')
            if attempt < attempts - 1:  # Don't sleep on last attempt
                time.sleep(context.retry_delay)'''

        # Status code verification
        elif "receive" in normalized and "response" in normalized:
            status_match = re.search(r'\d+', step)
            if status_match:
                status_code = int(status_match.group())
                return f'''    """Validate the response status code matches the expected value."""
    assert context.response is not None, "No response received from API"
    assert context.status_code == {status_code}, \\
        f'Expected status code {status_code}, got {{context.status_code}}' '''
            return '''    """Validate the response status code."""
    assert context.response is not None, "No response received from API"'''

        # Message ID verification
        elif "message id" in normalized:
            return '''    """Verify response contains message ID."""
    assert context.response is not None, "No response received from API"
    response_data = context.response.json()
    assert 'message_id' in response_data, \\
        f'Response missing message_id field: {response_data}' '''

        # Default implementation
        return '''    """Step implementation pending."""
    assert True, "Step not implemented yet"'''
