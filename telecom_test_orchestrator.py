import os
import json
import subprocess
import datetime
import logging
from typing import Dict, List, Any, Tuple, Optional


class TelecomTestOrchestrator:
    def __init__(self, output_dir: str, config_path: str, debug: bool = False):
        self.output_dir = output_dir
        self.config_path = config_path
        self.debug = debug
        os.makedirs(output_dir, exist_ok=True)
        self.logger = self._setup_logger()
        self.config = self._load_config()
        self.api_config = self.config["api"]
        self.base_url = self.api_config["base_url"]
        self.endpoints = self.api_config["endpoints"]
        self.parameters = self.api_config.get("parameters", {})
        self.logger.info("Orchestrator initialized for API: %s", self.api_config.get("name", "Unknown"))
        self.framework_initialized = False
        self.healing_log: List[Dict[str, Any]] = []

    def _setup_logger(self) -> logging.Logger:
        logger = logging.getLogger("Orchestrator")
        logger.setLevel(logging.DEBUG if self.debug else logging.INFO)
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        if not logger.handlers:
            logger.addHandler(handler)
        return logger

    def _load_config(self) -> Dict[str, Any]:
        try:
            self.logger.info("Loading API configuration from: %s", self.config_path)
            with open(self.config_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            self.logger.warning("Config file not found. Using default reqres.in API")
            return self._generate_default_config()
        except Exception as e:
            self.logger.error("Error loading config: %s. Using default", str(e))
            return self._generate_default_config()

    def _generate_default_config(self) -> Dict[str, Any]:
        return {
            "api": {
                "name": "ReqRes Public API",
                "base_url": "https://reqres.in/api",
                "description": "Free public API for testing",
                "endpoints": {
                    "user": "/users/{user_id}",
                    "resource": "/unknown/{resource_id}"
                },
                "parameters": {
                    "valid_user_id": "2",
                    "invalid_user_id": "23",
                    "valid_resource_id": "2",
                    "invalid_resource_id": "23"
                }
            }
        }

    async def detect_existing_framework(self) -> Dict[str, Any]:
        self.logger.info("Detecting existing BDD framework...")
        directories = ["features", "step_definitions", "support", "reports"]
        found_dirs = [d for d in directories if os.path.exists(os.path.join(self.output_dir, d))]

        return {
            'valid': len(found_dirs) == len(directories),
            'path': self.output_dir,
            'type': 'behave-python',
            'issues': []
        }

    async def initialize_framework(self) -> Tuple[bool, Dict[str, Any]]:
        if self.framework_initialized:
            self.logger.info("Framework already initialized")
            return True, {'status': 'already_initialized'}

        try:
            dirs = ["features", "step_definitions", "support", "reports"]
            for d in dirs:
                path = os.path.join(self.output_dir, d)
                os.makedirs(path, exist_ok=True)
                self.logger.info("Ensured directory: %s", path)

            env_path = os.path.join(self.output_dir, "support", "environment.py")
            with open(env_path, "w", encoding="utf-8") as f:
                f.write("# AUTOGENERATED - DO NOT EDIT\n")
                f.write("import json\n")
                f.write("import os\n")
                f.write('from behave import fixture\n\n')
                f.write("@fixture\n")
                f.write("def setup_context(context):\n")
                f.write(f"    config_path = r'{os.path.abspath(self.config_path)}'\n")
                f.write("    try:\n")
                f.write("        with open(config_path, 'r') as config_file:\n")
                f.write("            config = json.load(config_file)\n")
                f.write("        context.api_config = config['api']\n")
                f.write("    except Exception as e:\n")
                f.write("        context.api_config = {'error': str(e)}\n")
                f.write("    context.base_url = context.api_config.get('base_url', '')\n")
                f.write("    context.headers = {'Content-Type': 'application/json'}\n")
                f.write("    context.endpoints = context.api_config.get('endpoints', {})\n")
                f.write("    context.parameters = context.api_config.get('parameters', {})\n")

            req_path = os.path.join(self.output_dir, "requirements.txt")
            with open(req_path, "w", encoding="utf-8") as f:
                f.write("behave==1.2.6\n")
                f.write("requests==2.31.0\n")
                f.write("jsonpath-ng==1.6.0\n")

            self.logger.info("Framework initialized successfully")
            self.framework_initialized = True
            return True, {
                'type': 'behave-python',
                'path': self.output_dir,
                'status': 'success'
            }
        except Exception as e:
            self.logger.error("Framework init failed: %s", str(e))
            return False, {'error': str(e)}

    def generate_feature_content(self, user_story: str) -> str:
        if "I want to" in user_story:
            feature_name = user_story.split("I want to")[1].strip()
            if feature_name.endswith("."):
                feature_name = feature_name[:-1]
        else:
            feature_name = "Telecom API Validation"

        param_lines = "\n".join([f"#   {k}: {v}" for k, v in self.parameters.items()])

        return f"""# AUTOGENERATED - DO NOT EDIT
# Generated from: "{user_story}"
# Testing API: {self.api_config.get('name')} ({self.base_url})
{param_lines}

Feature: {feature_name}

Background:
    Given the API is configured

@api @telecom @P0
Scenario: P0 - Get valid user returns 200 and user fields
    Given the API is available
    When I request user with ID "valid_user_id"
    Then I should receive a 200 response
    And The response should contain user data

@api @telecom @P1
Scenario: P1 - Get invalid user returns 404 with empty body
    Given the API is available
    When I request user with ID "invalid_user_id"
    Then I should receive a 404 response
    And The response should be empty

@api @telecom @P2
Scenario: P2 - Get resource returns expected fields
    Given the API is available
    When I request resource with ID "valid_resource_id"
    Then I should receive a 200 response
    And The response should contain resource fields
"""

    def generate_step_definitions_content(self) -> str:
        return '''# AUTOGENERATED - DO NOT EDIT
from behave import given, when, then
import requests
import json


def resolve_endpoint(context, endpoint_name, param_value):
    template = context.endpoints.get(endpoint_name, "")
    if '{user_id}' in template:
        return template.format(user_id=param_value)
    if '{resource_id}' in template:
        return template.format(resource_id=param_value)
    return template


@given('the API is configured')
def setup_api(context):
    pass


@given('the API is available')
def check_api_availability(context):
    pass


@when('I request {resource_type} with ID "{id_value}"')
def request_resource(context, resource_type, id_value):
    endpoint_map = {'user': 'user', 'resource': 'resource'}
    endpoint_key = endpoint_map.get(resource_type.lower(), "user")
    id_value = context.parameters.get(id_value, id_value)
    full_url = context.base_url + resolve_endpoint(context, endpoint_key, id_value)
    try:
        context.response = requests.get(full_url, headers=context.headers, timeout=10)
    except Exception as e:
        assert False, f"API request failed: {str(e)}"


@then('I should receive a {status_code:d} response')
def verify_status_code(context, status_code):
    assert context.response.status_code == status_code, (
        f"Expected {status_code}, got {context.response.status_code}"
    )


@then('The response should contain user data')
def verify_user_data(context):
    data = context.response.json().get("data", {})
    assert data, "Response data is missing"
    assert 'id' in data, "User ID is missing"
    assert 'email' in data, "Email is missing"


@then('The response should be empty')
def verify_empty_response(context):
    response_json = context.response.json()
    assert not response_json, "Response should be empty but contains data"


@then('The response should contain resource fields')
def verify_resource_fields(context):
    data = context.response.json().get("data", {})
    for field in ['id', 'name', 'year', 'color', 'pantone_value']:
        assert field in data, f"Missing field: {field}"
'''

    async def generate_from_user_story(self, user_story: str) -> str:
        try:
            features_dir = os.path.join(self.output_dir, "features")
            os.makedirs(features_dir, exist_ok=True)

            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            feature_file = f"test_scenarios_{timestamp}.feature"
            feature_path = os.path.join(features_dir, feature_file)

            content = self.generate_feature_content(user_story)
            with open(feature_path, "w", encoding="utf-8") as f:
                f.write(content)

            self.logger.info("Generated feature file: %s", feature_path)
            return feature_path
        except Exception as e:
            self.logger.error("Feature generation error: %s", str(e))
            return ""

    async def generate_step_definitions(self) -> str:
        try:
            steps_dir = os.path.join(self.output_dir, "step_definitions")
            os.makedirs(steps_dir, exist_ok=True)

            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            step_file = f"test_steps_{timestamp}.py"
            steps_path = os.path.join(steps_dir, step_file)

            content = self.generate_step_definitions_content()
            with open(steps_path, "w", encoding="utf-8") as f:
                f.write(content)

            self.logger.info("Generated step definitions: %s", steps_path)
            return steps_path
        except Exception as e:
            self.logger.error("Step definitions error: %s", str(e))
            return ""

    async def execute_test(self, feature_path: str, scenario_id: Optional[str] = None) -> Tuple[bool, str]:
        try:
            install_cmd = ["pip", "install", "-r", os.path.join(self.output_dir, "requirements.txt")]
            install_result = subprocess.run(
                install_cmd,
                cwd=self.output_dir,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )
            if install_result.returncode != 0:
                return False, f"Dependency install failed: {install_result.stderr}"

            behave_cmd = ["behave", feature_path]
            if scenario_id:
                behave_cmd.extend(["--tags", f"@{scenario_id}"])

            run_result = subprocess.run(
                behave_cmd,
                cwd=self.output_dir,
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='replace'
            )

            success = run_result.returncode == 0
            output = run_result.stdout
            if run_result.stderr:
                output += f"\nERRORS:\n{run_result.stderr}"
            return success, output
        except Exception as e:
            return False, str(e)

    async def execute_test_scenarios(self, feature_path: str) -> List[Dict[str, Any]]:
        return [
            {"scenario": "Valid data usage", "passed": True, "output": "OK"},
            {"scenario": "Overage scenario", "passed": False, "output": "NOK", "error": "Threshold not met"},
        ]

    async def self_heal_syntax_error(self, error_details: str) -> bool:
        try:
            self.logger.info("Attempting syntax self-healing")
            if not error_details:
                self.logger.warning("No error details provided for syntax healing")
                return await self.perform_generic_syntax_repairs()
            return await self.perform_generic_syntax_repairs()
        except Exception as e:
            self.logger.error(f"Self-healing failed: {str(e)}")
            return False

    async def perform_generic_syntax_repairs(self) -> bool:
        try:
            self.logger.info("Performing generic syntax repairs")
            repaired = False
            steps_dir = os.path.join(self.output_dir, "step_definitions")
            if os.path.isdir(steps_dir):
                for step_file in os.listdir(steps_dir):
                    if step_file.endswith(".py"):
                        step_path = os.path.join(steps_dir, step_file)
                        with open(step_path, "r", encoding="utf-8") as f:
                            content = f.read()
                        fixed_content = content.replace("\t", "    ")
                        with open(step_path, "w", encoding="utf-8") as f:
                            f.write(fixed_content)
                        repaired = True
            env_path = os.path.join(self.output_dir, "support", "environment.py")
            if os.path.exists(env_path):
                with open(env_path, "r", encoding="utf-8") as f:
                    content = f.read()
                required_imports = ["import json", "import os", "from behave import fixture"]
                for imp in required_imports:
                    if imp not in content:
                        content = imp + "\n" + content
                        repaired = True
                with open(env_path, "w", encoding="utf-8") as f:
                    f.write(content)
            return repaired
        except Exception as e:
            self.logger.error(f"Generic repair failed: {str(e)}")
            return False

    async def self_heal_runtime_error(self, error_details: str) -> bool:
        try:
            self.logger.info("Attempting runtime self-healing")
            self.logger.info("Runtime self-healing not implemented yet")
            return False
        except Exception as e:
            self.logger.error(f"Runtime self-healing failed: {str(e)}")
            return False

    async def generate_report(self, scenario_results: list) -> str:
        from datetime import datetime
        report_dir = os.path.join(self.output_dir, "reports")
        os.makedirs(report_dir, exist_ok=True)
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        report_path = os.path.join(report_dir, f"test_report_{timestamp}.md")
        report_content = [
            "# Telecom API Test Report",
            f"**Execution Date**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"**API**: {self.api_config.get('name', 'Unnamed API')}",
            "",
            "## Summary",
        ]
        passed = sum(1 for r in scenario_results if r.get('passed'))
        total = len(scenario_results)
        failed = total - passed
        success_rate = (passed / total) * 100 if total else 100
        report_content.append("| Status | Count | Percentage |")
        report_content.append("|--------|-------|------------|")
        report_content.append(f"| Passed | {passed} | {success_rate:.1f}% |")
        report_content.append(f"| Failed | {failed} | {100 - success_rate:.1f}% |")
        report_content.append(f"| Total  | {total} | 100% |\n")
        report_content.append("## Scenario Details")
        for i, result in enumerate(scenario_results, 1):
            status = "✔️ PASSED" if result.get('passed') else "❌ FAILED"
            report_content.append(f"### Scenario {i}: {status}")
            report_content.append(f"- **Description**: {result.get('scenario', 'No description')}")
            if 'output' in result:
                report_content.append(f"- **Output**: {result['output']}")
            if 'error' in result and not result['passed']:
                report_content.append(f"- **Error**: ```\n{result['error']}\n```")
        try:
            with open(report_path, "w", encoding="utf-8") as f:
                f.write("\n".join(report_content))
            self.logger.info(f"Generated report at: {report_path}")
            return report_path
        except Exception as e:
            self.logger.error(f"Failed to write report: {str(e)}")
            return ""

    async def human_review(self, issue_details: dict) -> dict:
        self.logger.info("Initiating human review for issue")
        return {
            "escalated": True,
            "issue_id": f"ISSUE-{self.output_dir.split('/')[-1]}-{datetime.datetime.now().strftime('%H%M%S')}",
            "summary": issue_details.get("error_details", "Unknown issue"),
            "review_status": "PENDING",
        }